/**
 * @fileoverview Connector component for managing integration connectors
 * Requirements addressed:
 * - Integration Capabilities (Technical Specification/Scope/Core Features and Functionalities)
 *   Implements frontend logic for managing 500+ app connectors, authentication management,
 *   rate limiting, and retry logic.
 */

/**
 * Human Tasks:
 * 1. Review error handling strategies for production deployment
 * 2. Verify accessibility compliance for integration forms
 * 3. Test connector management with large datasets (500+ connectors)
 * 4. Validate rate limiting behavior in production environment
 */

// react v18.2.0
import React, { useState, useCallback } from 'react';

// Internal imports
import { Integration, integrationId, name, auth } from '../../types/integration.types';
import useIntegration from '../../hooks/useIntegration';
import { Button } from '../../components/common/Button/Button';
import Input from '../../components/common/Input/Input';

interface ConnectorProps {
  /**
   * Optional initial integration data
   */
  initialIntegration?: Integration;
  
  /**
   * Optional callback for when an integration is created or updated
   */
  onIntegrationChange?: (integration: Integration) => void;
}

const Connector: React.FC<ConnectorProps> = ({
  initialIntegration,
  onIntegrationChange
}) => {
  // State for managing form inputs
  const [integrationName, setIntegrationName] = useState(initialIntegration?.name || '');
  const [authConfig, setAuthConfig] = useState(initialIntegration?.auth || {
    username: '',
    password: '',
    token: ''
  });

  // Get integration management functions from custom hook
  const {
    integrations,
    loading,
    error,
    createNewIntegration,
    removeIntegration,
    refreshIntegrations
  } = useIntegration();

  /**
   * Handles the creation of a new integration
   */
  const handleCreateIntegration = useCallback(async () => {
    try {
      const newIntegration: Integration = {
        integrationId: '', // Will be generated by backend
        name: integrationName,
        description: '', // Optional field
        version: '1.0.0',
        status: 'configuring',
        auth: authConfig,
        rateLimit: {
          maxRequests: 100,
          windowSeconds: 60
        },
        retry: {
          maxAttempts: 3,
          initialDelayMs: 1000,
          backoffMultiplier: 2,
          maxDelayMs: 10000
        },
        workflows: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      await createNewIntegration(newIntegration);
      onIntegrationChange?.(newIntegration);
      
      // Reset form
      setIntegrationName('');
      setAuthConfig({
        username: '',
        password: '',
        token: ''
      });
    } catch (err) {
      console.error('Failed to create integration:', err);
    }
  }, [integrationName, authConfig, createNewIntegration, onIntegrationChange]);

  /**
   * Handles the deletion of an integration
   */
  const handleDeleteIntegration = useCallback(async (id: string) => {
    try {
      await removeIntegration(id);
      refreshIntegrations();
    } catch (err) {
      console.error('Failed to delete integration:', err);
    }
  }, [removeIntegration, refreshIntegrations]);

  return (
    <div className="connector-container">
      {/* Integration creation form */}
      <div className="connector-form">
        <h2>Create New Integration</h2>
        <Input
          type="text"
          placeholder="Integration Name"
          value={integrationName}
          onChange={(e) => setIntegrationName(e.target.value)}
          required
          name="integration-name"
        />
        
        <Input
          type="text"
          placeholder="Username"
          value={authConfig.username}
          onChange={(e) => setAuthConfig({ ...authConfig, username: e.target.value })}
          required
          name="auth-username"
        />
        
        <Input
          type="password"
          placeholder="Password"
          value={authConfig.password}
          onChange={(e) => setAuthConfig({ ...authConfig, password: e.target.value })}
          required
          name="auth-password"
        />
        
        <Input
          type="text"
          placeholder="API Token"
          value={authConfig.token}
          onChange={(e) => setAuthConfig({ ...authConfig, token: e.target.value })}
          required
          name="auth-token"
        />

        <Button
          variant="primary"
          onClick={handleCreateIntegration}
          disabled={loading || !integrationName}
          isLoading={loading}
        >
          Create Integration
        </Button>
      </div>

      {/* Integration list */}
      <div className="connector-list">
        <h2>Existing Integrations</h2>
        {error && (
          <div className="error-message">
            Failed to load integrations: {error.message}
          </div>
        )}
        
        {loading ? (
          <div>Loading integrations...</div>
        ) : (
          <ul>
            {integrations.map((integration) => (
              <li key={integration.integrationId} className="integration-item">
                <div className="integration-info">
                  <span className="integration-name">{integration.name}</span>
                  <span className="integration-status">{integration.status}</span>
                </div>
                <Button
                  variant="secondary"
                  onClick={() => handleDeleteIntegration(integration.integrationId)}
                  size="small"
                >
                  Delete
                </Button>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
};

export default Connector;